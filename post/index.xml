<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Even - A super concise theme for Hugo</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 25 Apr 2019 08:36:54 -0700</lastBuildDate>
    
	<atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>let,apply,run,with的区别</title>
      <link>http://localhost:1313/post/kotlin/letapplyrunwith%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 25 Apr 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/kotlin/letapplyrunwith%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Kotlin中let,apply,run,with的区别</description>
    </item>
    
    <item>
      <title>Dart基础语法</title>
      <link>http://localhost:1313/post/flutter/dart%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/dart%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>方法 Dart下??、??=属于操作符，如：AA ?? &amp;quot;999&amp;quot;表示如果AA为空，返回999；AA ??=&amp;quot;999&amp;quot; 表示如果AA为空，给AA设</description>
    </item>
    
    <item>
      <title>Expanded 和 Flexible</title>
      <link>http://localhost:1313/post/flutter/widget/expanded%E5%92%8Cflexible%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/expanded%E5%92%8Cflexible%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Expanded 和 Flexible的区别</description>
    </item>
    
    <item>
      <title>Flutter主题（Theme）</title>
      <link>http://localhost:1313/post/flutter/%E4%B8%BB%E9%A2%98-theme/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/%E4%B8%BB%E9%A2%98-theme/</guid>
      <description>参考： 主题-Theme Theme Widget 可以为Material APP 定义主题数据（ThemeData），Material组件库里很多Widget都使用了主题数</description>
    </item>
    
    <item>
      <title>Flutter常用布局</title>
      <link>http://localhost:1313/post/flutter/widget/flutter%E5%B8%83%E5%B1%80/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/flutter%E5%B8%83%E5%B1%80/</guid>
      <description>Flutter常用布局</description>
    </item>
    
    <item>
      <title>Flutter开发中一些问题的总结</title>
      <link>http://localhost:1313/post/flutter/flutter%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/flutter%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>参考：Flutter实战进阶 container width、height 100% 1 2 3 4 5 FractionallySizedBox( widthFactor: 1, heightFactor: 1, child: , ) 1 2 double width = MediaQuery.of(context).size.width double height = MediaQuery.of(context).size.height 沉浸式背景图片 背景图片铺满AppBar</description>
    </item>
    
    <item>
      <title>Flutter路由管理</title>
      <link>http://localhost:1313/post/flutter/%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/%E8%B7%AF%E7%94%B1/</guid>
      <description>路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常</description>
    </item>
    
    <item>
      <title>FutureBuilder</title>
      <link>http://localhost:1313/post/flutter/widget/futurebuilder/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/futurebuilder/</guid>
      <description>FutureBuilder使用，以及防止FutureBuilder进行不必要的重绘。</description>
    </item>
    
    <item>
      <title>Java7 ConcurrentHashMap</title>
      <link>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/concurrenthashmap/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/concurrenthashmap/</guid>
      <description>Java7中ConcurrentHashMap</description>
    </item>
    
    <item>
      <title>Java7 HashMap</title>
      <link>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashmap/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hashmap/</guid>
      <description>Java7 HashMap</description>
    </item>
    
    <item>
      <title>ListTile</title>
      <link>http://localhost:1313/post/flutter/widget/listtile/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/listtile/</guid>
      <description>一个固定高度的行，通常包含一些文本，以及一个行前或行尾图标。</description>
    </item>
    
    <item>
      <title>ListView的基本使用</title>
      <link>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/listview/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/listview/</guid>
      <description>ListView是最常用的可滚动Widget，它可以沿着一个方向限行排布所有子Widget。</description>
    </item>
    
    <item>
      <title>Padding、Align、Center详解</title>
      <link>http://localhost:1313/post/flutter/widget/-paddingaligncenter%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/-paddingaligncenter%E8%AF%A6%E8%A7%A3/</guid>
      <description>Padding、Align、Center详解</description>
    </item>
    
    <item>
      <title>SliverAppBar</title>
      <link>http://localhost:1313/post/flutter/widget/sliverappbar/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/sliverappbar/</guid>
      <description>AppBar和SliverAppBar都是继承StatefulWidget类，都代表Toolbar,二者的区别在于AppBar位置的固定在应用最上面，而SliverAppBar是可以跟随内容滚动的。</description>
    </item>
    
    <item>
      <title>StatefulWiget</title>
      <link>http://localhost:1313/post/flutter/widget/statefulwiget/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/statefulwiget/</guid>
      <description>你需要创建管理的是主要是 State ， 通过 State 的 build 方法去构建控件。在 State 中，你可以动态改变数据，这类似 MVVM 实现，在 setState 之后，改变的数据会触发 Widget 重新构建刷新。而</description>
    </item>
    
    <item>
      <title>不透明控件Opacity</title>
      <link>http://localhost:1313/post/flutter/widget/%E4%B8%8D%E9%80%8F%E6%98%8E%E6%8E%A7%E4%BB%B6-opacity/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/%E4%B8%8D%E9%80%8F%E6%98%8E%E6%8E%A7%E4%BB%B6-opacity/</guid>
      <description>Opacity控件调整子控件的不透明度，使子控件透明度，不透明度从0.0到1.0之间，0.0表示完全透明，1.0表示完全不透明。</description>
    </item>
    
    <item>
      <title>二叉查找树（Binary Search Tree）</title>
      <link>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</guid>
      <description>二叉查找树（Binary Search Tree）</description>
    </item>
    
    <item>
      <title>可滚动Widget简介</title>
      <link>http://localhost:1313/post/flutter/widget/flutter%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/flutter%E9%A1%B5%E9%9D%A2/</guid>
      <description>Flutter页面 Flutter 中除了布局的 Widget，还有交互显示的 Widget 和完整页面呈现的Widget。其中常见的有 MaterialApp、Scaffo</description>
    </item>
    
    <item>
      <title>可滚动Widget简介</title>
      <link>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget%E7%AE%80%E4%BB%8B/</guid>
      <description>当内容超过显示视口（ViewPort）时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了可滚动Wi</description>
    </item>
    
    <item>
      <title>滚动监听及控制</title>
      <link>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/%E6%BB%9A%E5%8A%A8%E7%9B%91%E5%90%AC%E5%8F%8A%E6%8E%A7%E5%88%B6scrollcontroller/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/flutter/%E5%8F%AF%E6%BB%9A%E5%8A%A8widget/%E6%BB%9A%E5%8A%A8%E7%9B%91%E5%90%AC%E5%8F%8A%E6%8E%A7%E5%88%B6scrollcontroller/</guid>
      <description>以ListView为例，展示ScrollController的具体用法。最后，再介绍一下路由切换时如何保存滚动位置。</description>
    </item>
    
    <item>
      <title>红黑树简介</title>
      <link>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Thu, 21 Mar 2019 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/post/java/-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>红黑树（R-B Tree）</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/android/dagger2/component%E7%9A%84%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB%E4%B8%8Esubcomponent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/android/dagger2/component%E7%9A%84%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB%E4%B8%8Esubcomponent/</guid>
      <description>Component的组织关系与SubComponent 多个Component之间有相同的依赖，那么该如何处理它们之间的关系？
前言 先看下面一个场景
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class Man { @Inject Car car; public void goWork() { ... car.go(); ... } } public class Friend { @Inject Car car; // 车是向 Man 借的  public void goSightseeing() { ... car.go(); ... } }   Man 有一辆车，Friend 没有车，但是他可以借 Man 的车出去游玩下，提供 Car 实例的CarModule不变，那么我们应该怎么设计 Component 呢？</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/android/dagger2/dagger2%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/android/dagger2/dagger2%E5%85%A5%E9%97%A8/</guid>
      <description>入门 要实现依赖注入，首先要声明一个依赖对象的需求，这个声明是通过@Inject注解来实现的，所以Car类的实现如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Car { String mName; @Inject Engine mEngine; public Car(Engine engine){ mEngine = engine; } public String getName(){ return mName; } Engine getEngine(){ return mEngine; } }   声明了需求之后，需要声明提供方。提供方声明有两种方式：
 使用@Inject注解被依赖对象的构造方法； 使用@Provide注解Module类的普通方法。  先用第一种来实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class Engine { public final int CYLINDER_FUEL_COST = 10; int mCylinderNumbers; @Inject public Engine(){ mCylinderNumbers = 1; } public Engine(int cylinderNumbers){ this.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/android/dagger2/scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/android/dagger2/scope/</guid>
      <description>Scope(作用域) Scope是用来确定注入的实例的生命周期的，如果没有使用Scope注解，Component每次调用Module中的provide方法或者Inject构造函数生成的工厂时都会创建一个新的实例，而使用Scope后可以复用之前的依赖实例。下面先介绍Scope的基本概念与原理，再分析Singleton、Reusable等作用域。
Scope基本概念 先介绍Scope的用法，@Scope是元注解，是用来标记自定义注解的，如下：
1 2 3 4  @Documented @Retention(RUNTIME) @Scope public @interface MyScope {}   MyScope就是一个Scope注解，Scope注解只能标注目标类、@provide方法和component。Scope注解要生效的话，需要同时标注在Component和提供依赖的示例的Module或者目标类上。Module中provide方法中的Scope注解必须和与之绑定的Component的Scope注解一样，否者作用域不同会导致编译时报错。例如，CarModule中的provide方法的Scope是MyScope的话，ManComponent的Scope必须是MyScope这样的作用域才会生效，而且不能是@Singleton或者其它Scope注解，不然编译时Dagger2会报错。
那么 Scope 注解又是如何产生作用的呢，怎么保证生成的依赖实例的生命周期呢？
在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理：
 When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected.
 当 Component 与 Module、目标类（需要被注入依赖）使用 Scope 注解绑定时，意味着 Component 对象持有绑定的依赖实例的一个引用直到 Component 对象本身被回收。也就是作用域的原理，其实是让生成的依赖实例的生命周期与 Component 绑定，Scope 注解并不能保证生命周期，要想保证赖实例的生命周期，需要确保 Component 的生命周期。</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/flutter/widget/image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/flutter/widget/image/</guid>
      <description>https://blog.csdn.net/poorkick/article/details/80458707</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/mybatis/_parameter%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/mybatis/_parameter%E4%BD%BF%E7%94%A8/</guid>
      <description>mybatis默认有两个内置参数： * _parameter:代表整个参数 * 单个参数：_parameter就是这个参数 * 多个参数：参数会被封装成一个map,_parameter就是这个map * _databaseId:如果配置了databaseIdProvider标签，_databaseId就是代表当前数据库的别名
简单数据类型 此时#{id,jdbcType=INTEGER}中id可以取任意名字如#{a,jdbcType=INTEGER}，如果需要if test则一定使用&amp;lt;if test = &amp;ldquo;_parameter !=null&amp;rdquo;&amp;gt;，此处一定使用_parameter!=null而不是id!=null
1 2 3 4 5 6 7 8  &amp;lt;select id=&amp;#34;selectByPrimaryKey&amp;#34; resultMap=&amp;#34;BaseResultMap&amp;#34; parameterType=&amp;#34;Java.lang.Integer&amp;#34; &amp;gt; select &amp;lt;include refid=&amp;#34;Base_Column_List&amp;#34; /&amp;gt; from base.tb_user &amp;lt;if test=&amp;#34;_parameter != null&amp;#34;&amp;gt; where id = #{id,jdbcType=INTEGER} &amp;lt;/if&amp;gt; &amp;lt;/select&amp;gt;   一个对象数据类型 此时#{name,jdbcType=CHAR},#{sex,jdbcType=CHAR}中的name和sex一定要使用user对象的属性名 测试user对象&amp;lt;if test=&amp;rdquo;_parameter != null&amp;rdquo;&amp;gt;, 测试user对象属性&amp;lt;if test=&amp;ldquo;name != null&amp;rdquo;&amp;gt; 或者&amp;lt;if test=&amp;ldquo;#{name} != null&amp;rdquo;&amp;gt;
两个对象数据类型 List&amp;lt;User&amp;gt; select(User user,Page page), 此时if test一定要&amp;lt;if test=&amp;rsquo;_parameter.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/mybatis/foreach/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/mybatis/foreach/</guid>
      <description>foreach 原文 foreach一共有三种类型，分别为List,array,Map三种
foreach 属性 属性 描述 item 循环体中的具体对象。支持属性的点路径访问，如item.age,item.info.details。
具体说明：在list和数组中是其中的对象，在map中是value。
该参数为必选。 collection 要做foreach的对象，作为入参时，List&amp;lt;?&amp;gt;对象默认用list代替作为键，数组对象有array代替作为键，Map对象没有默认的键。
当然在作为入参时可以使用@Param(&#34;keyName&#34;)来设置键，设置keyName后，list,array将会失效。 除了入参这种情况外，还有一种作为参数对象的某个字段的时候。举个例子：
如果User有属性List ids。入参是User对象，那么这个collection = &#34;ids&#34;
如果User有属性Ids ids;其中Ids是个对象，Ids有个属性List id;入参是User对象，那么collection = &#34;ids.id&#34;
上面只是举例，具体collection等于什么，就看你想对那个元素做循环。
该参数为必选。 separator 元素之间的分隔符，例如在in()的时候，separator=&#34;,&#34;会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样。该参数可选。 open foreach代码的开始符号，一般是(和close=&#34;)&#34;合用。常用在in(),values()时。该参数可选。 close foreach代码的关闭符号，一般是)和open=&#34;(&#34;合用。常用在in(),values()时。该参数可选。 index 在list和数组中,index是元素的序号，在map中，index是元素的key，该参数可选。  List测试  Array大同小异
 SQL
1 2 3 4 5 6 7 8 9 10 11 12 13  drop table users if exists; create table users ( id int, name varchar(20) ); insert into users (id, name) values(1, &amp;#39;User1&amp;#39;); insert into users (id, name) values(2, &amp;#39;User2&amp;#39;); insert into users (id, name) values(3, &amp;#39;User3&amp;#39;); insert into users (id, name) values(4, &amp;#39;User4&amp;#39;); insert into users (id, name) values(5, &amp;#39;User5&amp;#39;); insert into users (id, name) values(6, &amp;#39;User6&amp;#39;);   User类 mapper.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/post/mybatis/mybatis-generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/mybatis/mybatis-generator/</guid>
      <description>mybatis-generator 简介 mybatis-geneator是一款mybatis自动代码生成工具，可以通过配置，快速生成mapper和xml文件。
配置 在项目的pom文件中添加插件配置
1 2 3 4 5 6 7 8 9  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt; &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt;   在main的resource目录下创建generatorConfig.xml文件。 配置文件中内容如下，可以根据需要自行修改
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  &amp;lt;?</description>
    </item>
    
  </channel>
</rss>